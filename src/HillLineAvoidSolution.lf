/**
 * Template for robot driving lab exercises.
 * This template just periodically switches between a
 * STOPPED and a DRIVING mode, updating the LCD display
 * on each change of mode.
 */
 target C {
    platform: {
      name: "rp2040",
      board: "pololu_3pi_2040_robot"
    },
    threading: false,
  }
  
  import Display from "lib/Display.lf"
  import Motors from "lib/Motors.lf"
  import AngleToDistance from "lib/RobotEncoderSolution.lf"
  import GyroAngle from "lib/IMU.lf"
  import Line from "lib/Line.lf"
 
  reactor Robot {
    input drive:int     // Toggle mode.
    motors = new Motors();
    angle = new GyroAngle();
    distance = new AngleToDistance();


    state Angle:float = 0;
    state Angles:float = 0;
    state flag:bool = false;
    state Distance:float = 0;
    timer t1(0, 1ms);

    reaction(startup) {=
      printf("hello world\n");
      gpio_init(PICO_DEFAULT_LED_PIN);
      gpio_set_dir(PICO_DEFAULT_LED_PIN, GPIO_OUT);
      gpio_put(PICO_DEFAULT_LED_PIN, true);
    =}
    reaction(t1) -> angle.trigger {=
      lf_set(angle.trigger,true);
    =}

    initial mode DRIVING {
        reaction(drive, angle.z, distance.right) -> motors.left_power,motors.right_power,LEFT,RIGHT {=
        // lf_set(disp.line3, "centerf");
        self->Angles = angle.z -> value;
        self->Angle += self->Angles * 0.001;
        lf_set(motors.left_power,0.2f);
        lf_set(motors.right_power,0.2f);
        if (drive->value == 1) {
            self->Angle = 0;
            self->flag = false;
            lf_set_mode(LEFT);
        }
        if (drive->value == 2) {
           self->Angle = 0;
           self->flag = false;
            lf_set_mode(RIGHT);
        } 
        
      =}
    }
    /*mode TURN{
      reaction(drive, angle.z) -> motors.left_power,motors.right_power,DRIVING, {=
        self->Angles = angle.z -> value;
        self->Angle += self->Angles * 0.001;
        if(self->Angle < -15) {
          self->flag = true;
        }
        if(!self->flag || drive->value == 1) {
          lf_set(motors.left_power,-0.1f);
          lf_set(motors.right_power,-0.2f);
        }
        if (drive->value == 0 && self->flag) {
            self->Angle = 0;
            self->Distance = distance.right->value;
            self->flag = false;
            lf_set_mode(DRIVING);
        }
        if (drive->value == 2 && self->flag) {
           self->Distance = distance.right->value;
           self->Angle = 0;
           self->flag = false;
            lf_set_mode(RIGHT);
        } 
        
      =}
        
    }*/
    mode LEFT {
      reaction(drive, angle.z, distance.right) -> motors.left_power,motors.right_power,DRIVING,RIGHT {=
        self->Angles = abs(angle.z -> value);
        self->Angle += self->Angles * 0.001;
        if(self->Angle > 4) {
          self->flag = true;
        }
        if(!self->flag || drive->value == 1) {
          lf_set(motors.left_power,-0.03f);
          lf_set(motors.right_power,-0.05f);
        }
        if (drive->value == 0 && self->flag) {
            self->Angle = 0;
            self->flag = false;
            lf_set_mode(DRIVING);
        }
        if (drive->value == 2 && self->flag) {
           self->Angle = 0;
           self->flag = false;
            lf_set_mode(RIGHT);
        } 
        
      =}
        
    }
    mode RIGHT {
      reaction(drive, angle.z, distance.right) -> motors.left_power,motors.right_power,DRIVING,LEFT {=
        self->Angles = angle.z -> value;
        self->Angle += self->Angles * 0.001;
        if(self->Angle > 3 ) {
          self->flag = true;
        }
        if(!self->flag || drive->value == 2) {
          lf_set(motors.left_power,-0.05f);
          lf_set(motors.right_power,-0.03f);
        }
        if (drive->value == 0 && self->flag) {
            self->Angle = 0;
            self->flag = false;
            lf_set_mode(DRIVING);
        }
        if (drive->value == 1 && self->flag) {
           self->Angle = 0;
           self->flag = false;
            lf_set_mode(LEFT);
        } 
        
      =}
    }
    
  }
  
  main reactor(calibration_time: time = 10 s) {
    timer t(0, 100 ms);
    robot = new Robot();
    disp = new Display();
    line = new Line();
    timer seconds(0, 100 ms)
    timer end_calibration(0, calibration_time)
    state count: int = 0
    reaction(startup) {=
      gpio_init(PICO_DEFAULT_LED_PIN);
      gpio_set_dir(PICO_DEFAULT_LED_PIN, GPIO_OUT);
      gpio_put(PICO_DEFAULT_LED_PIN, false);
    =}
    /*reaction(t) -> disp.line0, disp.line1, disp.line2 {=
      lf_set(disp.line0, "Well");
      lf_set(disp.line1, "Well");
      lf_set(disp.line2, "Well");
    =}
    */ 
    // reaction(seconds) -> disp.line3 {=
      // static char buf[17];
      // snprintf(buf, 17, "time:%8d s", self->count++);
      // lf_set(disp.line3, buf);
    // =}
  
    reaction(end_calibration) -> line.calibrate {=
      lf_set(line.calibrate, false);
    =}
  
    reaction(t) -> line.trigger,disp.line2 {=
      lf_set(line.trigger, true);
      
    =}
  
    reaction(line.reflect) -> disp.line0, disp.line1, disp.line2, disp.line3, robot.drive{=
      int judge = 800;
      
      
      static char buf0[17];
      snprintf(buf0, 17, "[0]:%4u [1]:%4u", line.reflect->value[0],  line.reflect->value[1]);
      lf_set(disp.line0,buf0);
      
      static char buf1[17];
      snprintf(buf1, 17, "[3]:%4u [4]:%4u", line.reflect->value[3], line.reflect->value[4 ]);
      lf_set(disp.line1,buf1);

      static char buf2[17];
      snprintf(buf2, 17, "[2]:%4u ", line.reflect->value[2]);
      lf_set(disp.line2, buf2);



      if(line.reflect->value[0] > judge) {
        lf_set(disp.line3, "left");
        lf_set(robot.drive,1);
      }
      else if(line.reflect->value[4] > judge ) {
        lf_set(disp.line3, "right");
        lf_set(robot.drive,2);
      }
      else if(line.reflect->value[1] > judge || line.reflect->value[2] > judge || line.reflect ->value[3] > judge) {
        lf_set(disp.line3, "centerb");
        lf_set(robot.drive,1);
      }
      else  {
        lf_set(disp.line3, "centerf");
        lf_set(robot.drive,0);
      }
      
    =}
  
  }
  